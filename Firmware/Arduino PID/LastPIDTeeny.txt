#include <DualVNH5019MotorShield.h>
#define ENCODER_OPTIMIZE_INTERRUPTS
#include <Encoder.h>

#include <PID_v1.h>


int EnA = 4;
int EnB = 6;
int In1 = 3;
int In2 = 5;
int In3 = 11;
int In4 = 12;

Encoder knobLeft(9, 10);
Encoder knobRight(7, 8);
 
double valeuraappliquer;
double valeuraappliquer2;
double kp =0.045, ki = 0.025 , kd = 0.001;             // A modifier


double input, output, setpoint; //Setpoint a rentrer manuellement, on va fixer une vitesse
long temp=0;
long temparret = 0; //temps qu'on a passé à l'arret jusqu'à maintenant
long longarret = 0; //somme des arret de la dernière fois, pas de la fois actuelle quand on est en plein arrêt
volatile long encoderPos = 0;
volatile long encoderPos2 = 0;
int interruptA;

PID myPID(&input, &output, &setpoint, kp, ki, kd, DIRECT);  //'DIRECT' le moteur ne sera pas à pleine puissance


double input2, output2, setpoint2; //Setpoint a rentrer manuellement, on va fixer une vitesse

PID myPID2(&input2, &output2, &setpoint2, kp, ki, kd, DIRECT);  //'DIRECT' le moteur ne sera pas à pleine puissance


static unsigned long temps = 0;
static unsigned long temps2 = 0;


unsigned long currentMillis;
unsigned long Millisdepart;

void setup() { 
  
  pinMode(EnA, OUTPUT);
  pinMode(EnB, OUTPUT);
  pinMode(In1, OUTPUT);
  pinMode(In2, OUTPUT);
  pinMode(In3, OUTPUT);
  pinMode(In4, OUTPUT);
  input = 0;
  //Initialiser le moteur avec polulu
  
  myPID.SetMode(AUTOMATIC);
  myPID.SetSampleTime(1); //Fréquence du PID dans le loop
  myPID.SetOutputLimits(-50, 50); //Va fixer le PWM entre -400 et 400 comme sur nos moteurs

  myPID2.SetMode(AUTOMATIC);
  myPID2.SetSampleTime(1); //Fréquence du PID dans le loop
  myPID2.SetOutputLimits(-50, 50); //Va fixer le PWM entre -400 et 400 comme sur nos moteurs


  Serial.begin (115200);                              //DEBUG
  valeuraappliquer = 0;
  valeuraappliquer2 = 0;

  Millisdepart = millis();
}

void loop()
{    
  asservissement(100, false);
  asservissement2(100, false);
}


void asservissement(double cible, bool arret)
{
  setpoint = cible;
  if(millis()- Millisdepart-temps >1)
  {
    input = knobRight.read();                                
    Serial.print(input);
    Serial.print(" , ");
    Serial.print(setpoint);
    Serial.print(" , ");
    Serial.print(input2);
    Serial.print(" , ");
    Serial.print(setpoint2);
    Serial.println();
    
    myPID.Compute();
    valeuraappliquer+= output;
   
   if(valeuraappliquer>0) {
     digitalWrite(In1, LOW);
     digitalWrite(In2, HIGH);
     analogWrite(EnA,valeuraappliquer);
   }
   else {
     digitalWrite(In1, LOW);
     digitalWrite(In2, LOW);
     analogWrite(EnA,valeuraappliquer);
   }
   
   knobRight.write(0);
   if(!arret){
      temps=millis()-Millisdepart;
      longarret = temparret;
    }
    else{
      temparret=millis() - Millisdepart- temps + longarret; 
    }
  }
}

void asservissement2(double cible, bool arret)
{
  setpoint2 = cible;
  if(millis()- Millisdepart-temps2 >1)
  {
    input2 = knobLeft.read();                                
    myPID2.Compute();
    valeuraappliquer2+= output2;
   
   if(valeuraappliquer2>0) {
     digitalWrite(In3, HIGH);
     digitalWrite(In4, LOW);
     analogWrite(EnB,valeuraappliquer2);
   }
   else {

     digitalWrite(In3, HIGH);
     digitalWrite(In4, LOW);
     analogWrite(EnB,valeuraappliquer2);
   }
   
   knobLeft.write(0);
   if(!arret){
      temps2=millis()-Millisdepart;
      longarret = temparret;
    }
    else{
      temparret=millis() - Millisdepart- temps2 + longarret; 
    }
  }
}